# 一级分类
## 整体认识和路由配置
![](assets/Pasted%20image%2020240519160447.png)
通过路由跳转传参，以此获取不同内容

## 面包屑导航渲染
![](assets/Pasted%20image%2020240519160941.png)
![](assets/Pasted%20image%2020240519161815.png)

## banner轮播图实现

## 激活状态显示
![](assets/Pasted%20image%2020240519162657.png)

## 解决路由缓存问题
![](assets/Pasted%20image%2020240519163057.png)
问题：一级分类的切换正好满足上面的条件，组件实例复用，导致分类数据无法更新 
解决问题的思路：1. 让组件实例不复用，强制销毁重建 2. 监听路由变化，变化之后执行数据更新操作
e5share的动态页是这个情况，通过监听路由变化来解决了，用的是watch

### 方案一：给router-view添加key（让组件实例不复用）
以当前路由完整路径为key的值，给router-view组件绑定
![](assets/Pasted%20image%2020240519163443.png)

### 方案二：使用beforeRouteUpdate导航钩子（监听路由变化）
![](assets/Pasted%20image%2020240519164402.png)

## 使用逻辑函数拆分业务
基于逻辑函数拆分业务是指把同一个组件中独立的业务代码通过函数做封装处理，提升代码的可维护性
![](assets/Pasted%20image%2020240519171455.png)

实现步骤：
1. 按照业务声明以 `use` 打头的逻辑函数
2. 把独立的业务逻辑封装到各个函数内部
3. 函数内部把组件中需要用到的数据或者方法return出去
4. 在组件中调用函数把数据或者方法组合回来使用

原来composables文件夹存放的就是这种东西（这是全局的，也可以在组件文件夹下创建composables文件夹）
感觉其实这就和对象有点像，是工厂函数？
原来还能这样，感觉很重要

views/Category/composables/useBanner.js
```js
// 封装banner轮播图相关的业务代码
import { ref, onMounted } from 'vue'
import { getBannerAPI } from '@/apis/home'

export function useBanner () {
  const bannerList = ref([])

  const getBanner = async () => {
    const res = await getBannerAPI({
      distributionSite: '2'
    })
    console.log(res)
    bannerList.value = res.result
  }

  onMounted(() => getBanner())

  return {
    bannerList
  }
}
```
在别的组件中就像其他组合式api一样调用useBanner，就可以拿到bannerList

[views/Category/composables/useBanner.js](Vue3小兔鲜%20-%20配套资料/03-code/vue-rabbit/src/views/Category/composables/useBanner.js)
[views/Category/composables/useCategory.js](Vue3小兔鲜%20-%20配套资料/03-code/vue-rabbit/src/views/Category/composables/useCategory.js)

### 核心思想总结
1. 逻辑拆分的过程是一个拆分再组合的过程。**原来这就叫组合式api**
2. 函数use打头，内部封装逻辑，return组件需要用到的数据和方法给组件消费
![](assets/Pasted%20image%2020240519173744.png)
